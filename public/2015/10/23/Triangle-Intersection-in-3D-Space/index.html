

<!DOCTYPE html>
<html lang="English">
<head>
    
    <meta name="author" content="Erich Spaker">
    
    <meta name="description" content="IdeaI was working on a game with a friend of mine when I came across this problem. The game is browser based, using webgl and three.js, and I wanted t">
    
    

    
    <link rel="alternative" href="YOUR_RSS_ADDRESS" title="mechASDF" type="application/atom+xml">
    
    
    

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Triangle Intersection in 3D Space | mechASDF</title>

    <!-- Bootstrap -->
    <link rel="stylesheet" href="/blog/bootstrap/css/bootstrap.min.css" type="text/css">
    <link rel="stylesheet" href="/blog/css/style.css" type="text/css">

    <!-- Javascript -->
    <script src="/blog/js/jquery-2.1.0.min.js"></script>
    <script src="/blog/js/jquery.backstretch.min.js"></script>
    <script src="/blog/js/background.js"></script>
    <script src="/blog/bootstrap/js/bootstrap.min.js"></script>
    <script src="/blog/js/headroom.min.js"></script>
    <script src="/blog/js/jquery.headroom.min.js"></script> 
    <script src="/blog/js/common.js"></script>

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
    <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
    <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->
</head>
<body>
    <nav class="navbar navbar-default navbar-fixed-top navbar-inverse" role="banner">
        <div class="container">
            <div class="navbar-header">
                <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                    <span class="sr-only">Toggle navigation</span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </button>
                <a class="navbar-brand" href="http://www.mechasdf.com/blog" title="mechASDF">mechASDF</a>
            </div>

            <div role="navigation" class="collapse navbar-collapse bs-navbar-collapse">
                

                <ul class="nav navbar-nav">
                    
                    <li id="nav-index"><a href="/blog">home</a></li>
                    
                    <li id="nav-resume"><a href="/blog/resume">resume</a></li>
                    
                    
                    <li><a href="https://github.com/blueforesticarus" target="_blank">GitHub</a></li>
                </ul>
            </div>
        </div>
    </nav>
    
    <script>
    var backRoot = "/blog/images/post-bg/";
    var backArray = [ "zoom1.svg", "zoom2.svg", "zoom3.svg",  ];
        
    $(function() {
        // page-id...
        var pageId = "2015/10/23/Triangle-Intersection-in-3D-Space/";
        pageId = pageId.substr(0, pageId.indexOf("/"));
        if(pageId === "") pageId = "index";
        
        $("#nav-" + pageId).addClass("active");
    });
    </script>

    <div id="post-flg" style="display:none;">This lets background.js know when it a post</div>
<article class="post container">
    <div class="well post-body first-post last-post">
        <h1>Triangle Intersection in 3D Space</h1>
        
        <div class="time-info">
Written:<time datetime="2015-10-23T04:57:39.000Z" itemprop="datePublished">2015-10-23</time>，Updated:<time datetime="2015-10-23T23:02:24.754Z" itemprop="dateModified">2015-10-23</time>，By <a href="http://www.mechasdf.com/blog" title="Erich Spaker">Erich Spaker</a>
        </div>
        
        <div class="post-body-inner">
            <div id="toc" class="toc-article well">
                <strong class="toc-title">Outline</strong>
                <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Idea"><span class="toc-number">1.</span> <span class="toc-text">Idea</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Algorithm_Structure"><span class="toc-number">2.</span> <span class="toc-text">Algorithm Structure</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Finding_Intersections"><span class="toc-number">3.</span> <span class="toc-text">Finding Intersections</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Getting_Plane_Equation"><span class="toc-number">3.1.</span> <span class="toc-text">Getting Plane Equation</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Getting_Intercept_of_Line_and_Plane-"><span class="toc-number">3.2.</span> <span class="toc-text">Getting Intercept of Line and Plane.</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Finding_the_Line_of_Intersection"><span class="toc-number">3.3.</span> <span class="toc-text">Finding the Line of Intersection</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Limiting_Checks"><span class="toc-number">4.</span> <span class="toc-text">Limiting Checks</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Setting_up_Geometries"><span class="toc-number">5.</span> <span class="toc-text">Setting up Geometries</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Conclusion"><span class="toc-number">6.</span> <span class="toc-text">Conclusion</span></a></li></ol>
            </div>
            
            <h2 id="Idea">Idea</h2><p>I was working on a game with a friend of mine when I came across this problem. The game is browser based, using webgl and <a href="http://threejs.org/" target="_blank" rel="external">three.js</a>, and I wanted to create a complex, bee-hive sort of structure which looked like this.</p>
<p><img src="step1.png" alt=""></p>
<p>The idea is that the spheroid would be a central room and the tube would be pathways leading off of it. The only problem was, that the two meshes intersected. The sphere could be seen inside the tube as it passed from the outside to the inside. To fix this I needed alter the sphere geometry to remove the parts which were inside the tube. I looked at some libraries people had already made (including <a href="https://github.com/evanw/csg.js/" target="_blank" rel="external">this</a>) however they were all either out of date, or simply took too much time to merge the geometries (crashing my browser). I decided just to figure it out myself. This post will explain the first step, finding all the intersections between the geometries. Here is a rendering where my code has taken the geometries and found all the intersections (colored red).</p>
<p><img src="with.png" alt=""></p>
<h2 id="Algorithm_Structure">Algorithm Structure</h2><p>The initial function of our algorithm will be called “intersect()”;<br>Intersect will take two parameters. A “gN” geometry and a “gM” geometry. It will cycle through each face of gM, and for each one of those faces it will cycle through each face of gN. For each pair of faces it will first check if an intersection is possible or likely, and if so it will find the line of intersection between each triangle. For testing it will also put this face onto a list, and then remove all faces of gN which have no intersections (this is just so we can see it working.) It is important to remember that in THREE.js, geometry faces contain three numbers: a,b and c, which correspond to indices in the list of vertices.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//takes two geometries and finds intersections</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">intersect</span>(<span class="params">gM,gN</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> faces = [];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">var</span> iM = <span class="number">0</span> ; iM &lt; gM.faces.length ; iM++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">var</span> iN = <span class="number">0</span> ; iN &lt; gN.faces.length ; iN++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(canIntersect(gM,iM,gN,iN) &amp;&amp; doesIntersect(gM, iM, gN, iN) &amp;&amp; faces.indexOf(iN) == -<span class="number">1</span>)&#123;</span><br><span class="line">				faces.push(iN);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span> ; i&lt;faces.length ; i++)&#123;</span><br><span class="line">		faces[i] = gN.faces[faces[i]];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">console</span>.log(faces.length + <span class="string">"/"</span> + gN.faces.length);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//comment the next line to prevent removing faces </span></span><br><span class="line">	gN.faces = faces;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>In some places in the code I have used a “equals()” function, which simply checks if two values are within an epsilon, to prevent mistakes when dealing with numbers which are essentially 0, but not quite.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">equals</span>(<span class="params">a,b,e</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!e)&#123;</span><br><span class="line">		e = .<span class="number">0000000001</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">Math</span>.abs(a-b) &lt; e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Finding_Intersections">Finding Intersections</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doesIntersect</span>(<span class="params">g1, i1, g2, i2</span>)</span>&#123;</span><br><span class="line">	<span class="comment">//find intersection of two faces or return false if there is none.</span></span><br><span class="line">	...</span><br></pre></td></tr></table></figure>
<p>“doesIntersect” will do most of the work in the algorithm. The function will take four parameters, two geometries (gM, gN) and the corresponding indices for the faces of those geometries (iM, iN). Since we are going to be doing a lot of work on these coordinates, it is helpful to put them into an easy to use object, like so.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doesIntersect</span>(<span class="params">g1, i1, g2, i2</span>)</span>&#123;</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	<span class="comment">//get triangles from geometries</span></span><br><span class="line">	t1 = &#123;</span><br><span class="line">		a: g1.vertices[g1.faces[i1].a],</span><br><span class="line">		b: g1.vertices[g1.faces[i1].b],</span><br><span class="line">		c: g1.vertices[g1.faces[i1].c],</span><br><span class="line">		ia: g1.faces[i1].a,</span><br><span class="line">		ib: g1.faces[i1].b,</span><br><span class="line">		ic: g1.faces[i1].c,</span><br><span class="line">		i: i1 &#125;;</span><br><span class="line"></span><br><span class="line">	t2 = &#123;</span><br><span class="line">		a: g2.vertices[g2.faces[i2].a],</span><br><span class="line">		b: g2.vertices[g2.faces[i2].b],</span><br><span class="line">		c: g2.vertices[g2.faces[i2].c],</span><br><span class="line">		ia: g2.faces[i2].a,</span><br><span class="line">		ib: g2.faces[i2].b,</span><br><span class="line">		ic: g2.faces[i2].c,</span><br><span class="line">		i: i2 &#125;;</span><br></pre></td></tr></table></figure>
<p>The rest of the function requires a lot of math, which I will do my best to explain. The most common method for finding the intersection of two triangles in 3D space is too:<br>    1 - Find the equation for the planes on which the the triangles reside.<br>    2 - Find the intersections of each line segment in triangle 1 with the plane of triangle two, and vice versa.<br>    3 - If both triangles make exactly two intersections with the other’s plane, then we know the line of intersection for each triangle is the line between it’s points of intersection.<br>    4 - If these lines of intersection overlap. Then then the intersection of the two triangles is the intersection of the two lines.</p>
<p>This concept is partially illustrated by the fallowing pictures. </p>
<p><img src="int.png" alt="Intersecting Triangles"></p>
<p>This means we will need a function for getting a plane equation given three points, and a function for finding the intercept of a line segment and a plane.</p>
<h3 id="Getting_Plane_Equation">Getting Plane Equation</h3><p>Planes are represented by the equation Ax + By + Cz = D.<br>A, B, and C are coefficients which determine the direction of the plane, and D is a constant which has to do with how far the plane is from the origin.<br>It also just so happens that the components of a vector <x,y,z> which is normal (perpendicular) to the plane, are proportional to the coefficients of the plane. (There is an excellent proof of this on <a href="https://www.khanacademy.org/math/linear-algebra/vectors_and_spaces/dot_cross_products/v/normal-vector-from-plane-equation" target="_blank" rel="external">Khan Academy</a>)<br>So how do we get the normal vector? Well, the cross product of two vectors must be orthogonal (perpendicular in 3D) to both vectors. (Vectors can be multiplied in two ways. In simple terms, dot product represents similarities between vectors, cross product represents differences)<br>The algebraic cross product (there is also the Geometric Cross product, which is a different version of the formula) is defined by: </x,y,z></p>
<p><code>A X B = &lt; (Ay * Bz − Az * By) , (Az * Bx − Ax * Bz) , (Ax * By − Ay * Bx) &gt;</code></p>
<p>If we find the cross product of two vectors which run along the plane, the product vector must be perpendicular to both vectors, and therefor the plane as well. We can find two vectors which lie on this plane by taking the difference of the triangles vertices.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getPlane</span>(<span class="params">a,b,c</span>)</span>&#123;</span><br><span class="line">	<span class="comment">//get the vectors from a to b and a to c</span></span><br><span class="line">	<span class="keyword">var</span> ab = &#123;</span><br><span class="line">		x: b.x-a.x, </span><br><span class="line">		y: b.y-a.y,</span><br><span class="line">		z: b.z-a.z</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> ac = &#123;</span><br><span class="line">		x: c.x-a.x, </span><br><span class="line">		y: c.y-a.y,</span><br><span class="line">		z: c.z-a.z</span><br><span class="line">	&#125;;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//the normal vector is the cross product</span></span><br><span class="line">	<span class="keyword">var</span> n = &#123;</span><br><span class="line">		x: ab.y*ac.z - ab.z*ac.y, </span><br><span class="line">		y: ab.z*ac.x - ab.x*ac.z,</span><br><span class="line">		z: ab.x*ac.y - ab.y*ac.x</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Now that we know the normal, we can use it’s components as the coefficients of our plane equation and solve for d, plugging in point a (or b, or c) as x,y and z since we know the point is on the plane. Then we return all the constants as a map.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//normal vector components are proportional to plane coefficients</span></span><br><span class="line"><span class="comment">//use this along with an original point to calculate "d" (Ax + By + Cz = D)</span></span><br><span class="line"><span class="keyword">var</span> d = n.x*c.x + n.y*c.y + n.z*c.z;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> = &#123;a:n.x, b:n.y, c: n.z, d:d&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="Getting_Intercept_of_Line_and_Plane-">Getting Intercept of Line and Plane.</h3><p>Since triangles are made up of line segments, the “intercept()” function will find the intersection of a line segment and a plane. First we turn the line segment into a parametric equation (assume m and n are the endpoints of the line segment).</p>
<p><code>x = (m.x-n.x)*t + n.x</code><br><code>y = (m.y-n.y)*t + n.y</code><br><code>z = (m.z-n.z)*t + n.z</code></p>
<p>Now we sub this into the plane equation: Ax + By + Cz = D, and we get.</p>
<p><code>A((m.x-n.x)*t + n.x) +  B((m.y-n.y)*t + n.y) + C((m.z-n.z)*t + n.z) = D</code></p>
<p>With some algebraic manipulation we can solve for t, which we can plug back into our parametric equation to get the intercept point.</p>
<p><code>t = (d - A*n.x - B*n.y - C*n.z) / (A*(m.x-n.x) + B*(m.y-n.y) + C*(m.z-n.z))</code>  </p>
<p><code>x = (m.x-n.x)*t + n.x</code><br><code>y = (m.y-n.y)*t + n.y</code><br><code>z = (m.z-n.z)*t + n.z</code></p>
<p>Because of the nature of the parametric equation, “t” will be between 0 and 1 if the intercept lies on the line segment. Our function will set a value “in” which is true only if the intercept is on the line segment. Finally, we have to consider the case where there is no intersection because the line and plane are parallel, in this case the denominator of t, (A<em>(m.x-n.x) + B</em>(m.y-n.y) + C*(m.z-n.z)), will be zero. Our code must handle this case and return no intersection. We will signify this by setting “ex” to false.</p>
<p>Now that we understand the math, writing the function is trivial.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">intercept</span> (<span class="params">a,b,c,d,p1,p2</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> bottom = (a*(p2.x-p1.x) + b*(p2.y-p1.y) + c*(p2.z-p1.z));</span><br><span class="line">	<span class="keyword">if</span>(equals(bottom,<span class="number">0</span>))&#123;</span><br><span class="line">		<span class="keyword">return</span> &#123;ex:<span class="literal">false</span>, <span class="keyword">in</span>:<span class="literal">false</span>&#125;;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> t = (d - a*p1.x - b*p1.y - c*p1.z) / bottom;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> &#123;</span><br><span class="line">		x: (p2.x-p1.x)*t + p1.x,</span><br><span class="line">		y: (p2.y-p1.y)*t + p1.y,</span><br><span class="line">		z: (p2.z-p1.z)*t + p1.z,</span><br><span class="line">		<span class="keyword">in</span>: (t &gt;= <span class="number">0</span> &amp;&amp; t&lt;=<span class="number">1</span>),</span><br><span class="line">		ex: <span class="literal">true</span>,</span><br><span class="line">		t:t</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Finding_the_Line_of_Intersection">Finding the Line of Intersection</h3><p>With these two functions written, the rest is mostly a matter of handling all the different possible cases, and getting the intersection of the intersections. First lets get our planes and intercepts (remember that t1 and t2 are our triangles);</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//first planes from triangles ([a,b,c,d] for ax+by+cz=d) </span></span><br><span class="line">p1 = getPlane(t1.a,t1.b,t1.c);</span><br><span class="line">p2 = getPlane(t2.a,t2.b,t2.c);</span><br><span class="line"></span><br><span class="line"><span class="comment">//get all the itercepts				</span></span><br><span class="line">ab_p1 = intercept(p1.a, p1.b, p1.c, p1.d, t2.a, t2.b);</span><br><span class="line">ac_p1 = intercept(p1.a, p1.b, p1.c, p1.d, t2.a, t2.c);</span><br><span class="line">bc_p1 = intercept(p1.a, p1.b, p1.c, p1.d, t2.b, t2.c);</span><br><span class="line"></span><br><span class="line">ab_p2 = intercept(p2.a, p2.b, p2.c, p2.d, t1.a, t1.b);</span><br><span class="line">ac_p2 = intercept(p2.a, p2.b, p2.c, p2.d, t1.a, t1.c);</span><br><span class="line">bc_p2 = intercept(p2.a, p2.b, p2.c, p2.d, t1.b, t1.c);</span><br></pre></td></tr></table></figure>
<p>Next we check to make sure there are some intersections. If there were not, then the triangles are parallel, and we return no intersection.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//detect if parallel + system check</span></span><br><span class="line"><span class="keyword">if</span>(!ab_p1.ex &amp;&amp; !ac_p1.ex &amp;&amp; !bc_p1.ex)&#123;</span><br><span class="line">	<span class="keyword">if</span>(!ab_p2.ex &amp;&amp; !ac_p2.ex &amp;&amp; !bc_p2.ex)&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">"triangles parallel"</span>);</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.warn(<span class="string">"something went wrong, inconsistent intersection"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Triangles can only intersect a plane on two edges, or none (if there is no intersection). The next part of the code will check if there are no intersections on the line segment, and return false if so.<br>If there are two intersections, it sets those as m and n in the variable i1 (for triangle 1) or i2 (for triangle two). i1 and i2 represent the lines of intersection of each triangle with the others plane.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//process intersections 1</span></span><br><span class="line"><span class="keyword">if</span>(ab_p1.in &amp;&amp; ac_p1.in &amp;&amp; bc_p1.in)&#123;</span><br><span class="line">	<span class="built_in">console</span>.warn(<span class="string">"something went wrong, cannot be three intersections"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>((!ab_p1.in &amp;&amp; !ac_p1.in &amp;&amp; !bc_p1.in) || (!ab_p2.in &amp;&amp; !ac_p2.in &amp;&amp; !bc_p2.in))&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">"triangles do not intersect"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">i1 = ab_p1.in ? (ac_p1.in ? &#123;m: ab_p1, n: ac_p1&#125; : &#123;m: ab_p1, n: bc_p1&#125; ) : &#123;m: ac_p1, n: bc_p1&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!i1.m || !i1.n)&#123;</span><br><span class="line">	<span class="built_in">console</span>.warn(<span class="string">"something went wrong, cannot be only one intersection"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//process intersections 2</span></span><br><span class="line"><span class="keyword">if</span>(ab_p2.in &amp;&amp; ac_p2.in &amp;&amp; bc_p2.in)&#123;</span><br><span class="line">	<span class="built_in">console</span>.warn(<span class="string">"something went wrong, cannot be three intersections"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>((!ab_p2.in &amp;&amp; !ac_p2.in &amp;&amp; !bc_p2.in) || (!ab_p2.in &amp;&amp; !ac_p2.in &amp;&amp; !bc_p2.in))&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">"triangles do not intersect 2"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">i2 = ab_p2.in ? (ac_p2.in ? &#123;m: ab_p2, n: ac_p2&#125; : &#123;m: ab_p2, n: bc_p2&#125; ) : &#123;m: ac_p2, n: bc_p2&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!i2.m || !i2.n)&#123;</span><br><span class="line">	<span class="built_in">console</span>.warn(<span class="string">"something went wrong, cannot be only one intersection"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>As you can see in this image (for which I altered the code to display i1 and i2), the place where the two lines intersect is the true intersection.</p>
<p><img src="step5.png" alt="lines"></p>
<p>To find the intersection we first need to determine which axis to measure the lines by. If they are not vertical we will use the x axis, otherwise we must use y or z.<br>Once we have our value to test we will determine the max and min for each line segment.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//get intersection of intersections</span></span><br><span class="line">	<span class="comment">//assume i2 and i1 are co-linear</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//determine which value to test</span></span><br><span class="line">	<span class="keyword">if</span>(!equals(i1.m.x , i2.n.x))&#123;</span><br><span class="line">		i1.m.v = i1.m.x;</span><br><span class="line">		i1.n.v = i1.n.x;</span><br><span class="line">		i2.m.v = i2.m.x;</span><br><span class="line">		i2.n.v = i2.n.x;</span><br><span class="line">	&#125;<span class="keyword">else</span> <span class="keyword">if</span>(!equals(i1.m.y , i2.n.y))&#123;</span><br><span class="line">		i1.m.v = i1.m.y;</span><br><span class="line">		i1.n.v = i1.n.y;</span><br><span class="line">		i2.m.v = i2.m.y;</span><br><span class="line">		i2.n.v = i2.n.y;</span><br><span class="line">	&#125;<span class="keyword">else</span> <span class="keyword">if</span>(!equals(i1.m.z , i2.n.z))&#123;</span><br><span class="line">		i1.m.v = i1.m.z;</span><br><span class="line">		i1.n.v = i1.n.z;</span><br><span class="line">		i2.m.v = i2.m.z;</span><br><span class="line">		i2.n.v = i2.n.z;</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="comment">//intercept of length zero</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//determine which is max, which is min</span></span><br><span class="line">	i1.max = i1.m.v &gt; i1.n.v ? i1.m : i1.n;</span><br><span class="line">	i1.min = i1.m.v &lt; i1.n.v ? i1.m : i1.n;	</span><br><span class="line">	i2.max = i2.m.v &gt; i2.n.v ? i2.m : i2.n;</span><br><span class="line">	i2.min = i2.m.v &lt; i2.n.v ? i2.m : i2.n;</span><br></pre></td></tr></table></figure>
<p>If the max(end) of one line segment comes before the min(start) of the other, then there is no intersection, and we return false.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//no intersection if lines are disconnected</span></span><br><span class="line"><span class="keyword">if</span>(i1.max.v &lt;= i2.min.v || i2.max.v &lt;= i1.min.v )&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Then all that is left to do is handle the four different configurations the lines could be in. We have to make sure we return the segment that is contained by both of the others. This line segment is the intersection of the two triangles.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> inner;</span><br><span class="line"></span><br><span class="line"><span class="comment">//handle four possible layouts</span></span><br><span class="line"><span class="keyword">if</span>(i1.min.v &lt; i2.min.v &amp;&amp; i2.max.v &lt; i1.max.v)&#123;</span><br><span class="line">	<span class="comment">//if i2 is fully within i1</span></span><br><span class="line">	inner = &#123;a:i2.min,b:i2.max&#125;;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(i2.min.v &lt; i1.min.v &amp;&amp; i1.max.v &lt; i2.max.v)&#123;</span><br><span class="line">	<span class="comment">//if i1 is fully within i2</span></span><br><span class="line">	inner = &#123;a:i1.min,b:i1.max&#125;;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(i2.min.v &lt; i1.min.v &amp;&amp; i2.max.v &lt; i1.max.v)&#123;</span><br><span class="line">	<span class="comment">//i1 and i2 over lap </span></span><br><span class="line">	inner = &#123;a:i1.min,b:i2.max&#125;;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(i1.min.v &lt; i2.min.v &amp;&amp; i1.max.v &lt; i2.max.v)&#123;</span><br><span class="line">	<span class="comment">//i1 and i2 over lap </span></span><br><span class="line">	inner = &#123;a:i2.min,b:i1.max&#125;;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">"something is wrong"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> inner;</span><br></pre></td></tr></table></figure>
<p>To display the intersections I added this line (which requires a global scene variable, representing a THREE.scene object) right before “return inner;”.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> geometry = <span class="keyword">new</span> THREE.Geometry();</span><br><span class="line">geometry.vertices.push(inner.a, inner.b);</span><br><span class="line"><span class="keyword">var</span> line = <span class="keyword">new</span> THREE.Line( geometry, <span class="keyword">new</span> THREE.LineBasicMaterial(&#123;</span><br><span class="line">	color: <span class="number">0xff0000</span>,</span><br><span class="line">	linewidth:<span class="number">7</span></span><br><span class="line">&#125;));</span><br><span class="line">scene.add( line );</span><br></pre></td></tr></table></figure>
<p><img src="step6.png" alt="intersection"></p>
<h2 id="Limiting_Checks">Limiting Checks</h2><p><img src="limit.png" alt="limit checks"></p>
<p>This is where “canIntersect()” comes in. Efficiency is a major concern. We have to check for intersection between each pair of faces separately. This means that as the number of faces grows, the number of checks will grow exponentially. Therefore it is very important to do as few computations as possible.</p>
<p>CanIntersect is called first, and doesIntersect should only be called if canIntersect returns true. This is so we don’t waste time finding planes and intersections when the triangles are so far away that intersection is impossible. To determine this canIntersect uses very quick comparisons for check for bounding box intersection. The bounding box is essentially the range of x y and z coordinates of the triangle. If the bounding boxes don’t overlap, intersection is impossible, so we can save time by not checking for it. </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">canIntersect</span>(<span class="params">gM, iM, gN, iN</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> stats = &#123;M:&#123;&#125;,N:&#123;&#125;&#125;;</span><br><span class="line">	stats.M.x = faceStat(gM,iM,<span class="string">"x"</span>);</span><br><span class="line">	stats.N.x = faceStat(gN,iN,<span class="string">"x"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(stats.M.x.max &lt; stats.N.x.min || stats.N.x.max &lt; stats.M.x.min)&#123;</span><br><span class="line">		<span class="comment">//console.log("x too far");</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	stats.M.y = faceStat(gM,iM,<span class="string">"y"</span>);</span><br><span class="line">	stats.N.y = faceStat(gN,iN,<span class="string">"y"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(stats.M.y.max &lt; stats.N.y.min || stats.N.y.max &lt; stats.M.y.min)&#123;</span><br><span class="line">		<span class="comment">//console.log("y too far");</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	stats.M.z = faceStat(gM,iM,<span class="string">"z"</span>);</span><br><span class="line">	stats.N.z = faceStat(gN,iN,<span class="string">"z"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(stats.M.z.max &lt; stats.N.z.min || stats.N.z.max &lt; stats.M.z.min)&#123;</span><br><span class="line">		<span class="comment">//console.log("z too far");</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">faceStat</span>(<span class="params">geometry, index, value</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> face = geometry.faces[index];</span><br><span class="line">	<span class="keyword">return</span> stat([geometry.vertices[face.a],geometry.vertices[face.b],geometry.vertices[face.c]], value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">stat</span>(<span class="params">objects, value</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> max = objects[<span class="number">0</span>][value];</span><br><span class="line">	<span class="keyword">var</span> min = objects[<span class="number">0</span>][value];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">1</span> ; i &lt; objects.length ; i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(objects[i][value] &lt; min)&#123;</span><br><span class="line">			min = objects[i][value];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(objects[i][value] &gt; max)&#123;</span><br><span class="line">			max = objects[i][value];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> &#123;max: max, min:min&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Stats and faceStats are helper functions which get the max and min for each triangle and each axis. There is another function I wrote which I used while coming up with this code called delimit. This function was applied to the tube geometry before calling intersect, and it eliminated all the faces that were two close or two far from the center, to intersect with the sphere at all (I could do this because I knew the size of the sphere and that it was centered on the origin). This was also helpful for testing, as it was easier to see what was going on. The two pictures above both used this function. </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">delimit</span>(<span class="params">g,min ,max</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(g);</span><br><span class="line">	<span class="keyword">var</span> minSq = min * min;</span><br><span class="line">	<span class="keyword">var</span> maxSq = max * max;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">var</span> i =<span class="number">0</span>; i&lt; g.faces.length ; i++)&#123;</span><br><span class="line">		<span class="keyword">var</span> face = g.faces[i];</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(g.vertices[face.a].lengthSq() &lt; minSq &amp;&amp;</span><br><span class="line">			g.vertices[face.b].lengthSq() &lt; minSq &amp;&amp;</span><br><span class="line">			g.vertices[face.c].lengthSq() &lt; minSq)&#123;</span><br><span class="line"></span><br><span class="line">			g.faces[i] = <span class="number">0</span>;			</span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(g.vertices[face.a].lengthSq() &gt; maxSq &amp;&amp;</span><br><span class="line">			g.vertices[face.b].lengthSq()  &gt; maxSq &amp;&amp;</span><br><span class="line">			g.vertices[face.c].lengthSq()  &gt; maxSq)&#123;</span><br><span class="line"></span><br><span class="line">			g.faces[i] = -<span class="number">1</span>;			</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> faces = []</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">var</span> i =<span class="number">0</span>; i&lt; g.faces.length ; i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(g.faces[i] != <span class="number">0</span> &amp;&amp; g.faces[i] != -<span class="number">1</span>)&#123;</span><br><span class="line">			faces.push(g.faces[i]);	</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	g.faces = faces;</span><br><span class="line">	g.computeFaceNormals();</span><br><span class="line">	g.computeVertexNormals();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The function could be adapted to return the removed faces, and then I could store them in a variable and add them back after running intercept. This would make the algorithm even faster as it would not have to even run canIntersect on the faces which are removed.</p>
<h2 id="Setting_up_Geometries">Setting up Geometries</h2><p>I will also go over the basics of how I create the scene in the first place.<br>The first thing that we need to do is create the geometries. If you arn’t familiar with THREE.js, it works based off meshes, geometries, and materials. The material says how a shape is displayed, a geometry describes all the faces(triangles) and vertices of a shape. And a mesh ties the material and geometry together with rotation, position and scale. For more on how THREE.js works you can look at their website (it has some excellent examples). </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//create a sphere shape with radius of 4000 and approximated by 20 X 20 sections;</span></span><br><span class="line"><span class="keyword">var</span> sphere = <span class="keyword">new</span> THREE.SphereGeometry(<span class="number">4000</span>,<span class="number">20</span>,<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//merge duplicate vertices, by default the sphere is two half circle pieces</span></span><br><span class="line">sphere.mergeVertices();</span><br><span class="line"></span><br><span class="line"><span class="comment">//for each vertice in the shape, apply a random shift.</span></span><br><span class="line">sphere.vertices.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">v</span>)</span>&#123;v.multiplyScalar(R(<span class="number">1.1</span>,.<span class="number">9</span>))&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//recalculate the normals for lighting (hmm, sort of like what we're doing)</span></span><br><span class="line">sphere.computeFaceNormals();</span><br><span class="line">sphere.computeVertexNormals();</span><br><span class="line"></span><br><span class="line"><span class="comment">//create a tube geometry in the shape of a "DecoratedTorusKnot5c" (this comes from one of the extra THREE.js lib files)</span></span><br><span class="line"><span class="keyword">var</span> geometry = <span class="keyword">new</span> THREE.TubeGeometry(<span class="keyword">new</span> THREE.Curves.DecoratedTorusKnot5c(), <span class="number">300</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//create a new transformation matrix</span></span><br><span class="line">trans = <span class="keyword">new</span> THREE.Matrix4();</span><br><span class="line"></span><br><span class="line"><span class="comment">//set rotation to 90 degrees (we want to rotate the tube)</span></span><br><span class="line">trans.makeRotationX(<span class="built_in">Math</span>.PI/<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//increase the scale, we want it to be bigger</span></span><br><span class="line">trans.scale(<span class="keyword">new</span> THREE.Vector3(<span class="number">150</span>,<span class="number">150</span>,<span class="number">150</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//apply the transform to the coordiantes</span></span><br><span class="line">geometry.applyMatrix(trans);</span><br><span class="line"></span><br><span class="line"><span class="comment">//call our functions</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//delimit(geometry,3600,4300);</span></span><br><span class="line">intersect(geometry, sphere);</span><br></pre></td></tr></table></figure>
<p>One thing to note is that we are NOT setting a transformation on the tube geometry like we would if it were a mesh. We are applying a transformation, which will alter the coordinates of the vertices based on the transformation. The next thing to do is to create the meshes and materials, and add them to the scene. </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mesh = THREE.SceneUtils.createMultiMaterialObject( sphere, [</span><br><span class="line"><span class="keyword">new</span> THREE.MeshLambertMaterial(&#123;</span><br><span class="line">	color: C(<span class="number">200</span>,<span class="number">250</span>),</span><br><span class="line">	side:THREE.DoubleSide,</span><br><span class="line">	transparent:<span class="literal">true</span>,</span><br><span class="line">	opacity: .<span class="number">7</span></span><br><span class="line">&#125;),</span><br><span class="line"><span class="keyword">new</span> THREE.MeshBasicMaterial(&#123;</span><br><span class="line">	color: <span class="number">0x000000</span>,</span><br><span class="line">	opacity: <span class="number">0.3</span>,</span><br><span class="line">	wireframe: <span class="literal">true</span>,</span><br><span class="line">	transparent: <span class="literal">true</span></span><br><span class="line">&#125;)]);</span><br><span class="line">scene.add(mesh);</span><br><span class="line"></span><br><span class="line">tubeMesh = THREE.SceneUtils.createMultiMaterialObject( geometry, [</span><br><span class="line"><span class="keyword">new</span> THREE.MeshLambertMaterial(&#123;</span><br><span class="line">	color: C(<span class="number">200</span>,<span class="number">250</span>),</span><br><span class="line">	side:THREE.DoubleSide,</span><br><span class="line">	shading: THREE.FlatShading,</span><br><span class="line">	transparent:<span class="literal">true</span>,</span><br><span class="line">	opacity: .<span class="number">7</span></span><br><span class="line">&#125;),</span><br><span class="line"><span class="keyword">new</span> THREE.MeshBasicMaterial(&#123;</span><br><span class="line">	color: <span class="number">0x000000</span>,</span><br><span class="line">	opacity: <span class="number">0.3</span>,</span><br><span class="line">	wireframe: <span class="literal">true</span>,</span><br><span class="line">	transparent: <span class="literal">true</span></span><br><span class="line">&#125;)]);</span><br><span class="line">scene.add(tubeMesh);</span><br></pre></td></tr></table></figure>
<p>I give them a random color using a function called “C()”.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">C</span>(<span class="params">max, min</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> R(max,min,<span class="literal">true</span>)*R(max,min,<span class="literal">true</span>)*R(max,min,<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">R</span>(<span class="params">max, min, step</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> r = <span class="built_in">Math</span>.random() * (max-min) + min;</span><br><span class="line">	<span class="keyword">if</span>(step)&#123;</span><br><span class="line">		r = <span class="built_in">Math</span>.floor(r);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>If you want to know how to set up a THREE.js renderer, scene, and camera, there are a wealth of <a href="https://aerotwist.com/tutorials/getting-started-with-three-js/" target="_blank" rel="external">tutorials</a> online.</p>
<h2 id="Conclusion">Conclusion</h2><p><img src="final.png" alt="final image"></p>
<p>This is just the first part of the project, I still have to assemble all the intersections into a shape to cut out of the sphere. That will have to be another post. There are still some ways this algorithm could be made more efficient, but it runs quick enough and that I think it will work for my purposes. I had a hard time finding a good explanation of how to find the intersections of triangles, so I hope I have explained the math in a way which makes sense. </p>
<p>Anyway, you can see a live demo of the project <a href="http://public.mechasdf.com/demo/intersection/final.html" target="_blank" rel="external">here</a>, as well as all the other <a href="http://public.mechasdf.com/demo/intersection/" target="_blank" rel="external">steps</a></p>
<p>The complete code can be found <a href="http://gist.github.com/blueForestIcarus/a3eea494ef26d4d1616f" target="_blank" rel="external">here</a>.</p>


			
            <section class="comment">
<!-- 多说评论框 start -->
	<div class="ds-thread" data-thread-key="/blog/2015/10/23/Triangle-Intersection-in-3D-Space/" data-title="Triangle Intersection in 3D Space" data-url="http://www.mechasdf.com/blog/blog/2015/10/23/Triangle-Intersection-in-3D-Space/"></div>
<!-- 多说评论框 end -->
<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
<script type="text/javascript">
var duoshuoQuery = {short_name:"YOUR_DUOSHUO_SHORT_NAME"};
	(function() {
		var ds = document.createElement('script');
		ds.type = 'text/javascript';ds.async = true;
		ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
		ds.charset = 'UTF-8';
		(document.getElementsByTagName('head')[0]
		 || document.getElementsByTagName('body')[0]).appendChild(ds);
	})();
	</script>
<!-- 多说公共JS代码 end -->
</section>
        </div>
    </div>
</article>

    <footer id="footer">
    <div id="bottom-tip">
        mechASDF
    </div>
        <small>Made with <a href="https://hexo.io/" target="_blank">Hexo</a>. Theme forked from <a href="https://github.com/XadillaX/hexadillax" target="_blank">Hexadillax</a></small><br />
        <small>&copy; 2014 Erich Spaker</small>
    </footer>

    


</body>
</html>

